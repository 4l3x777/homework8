# Bayan
## Задание 8
## Условие

Пользуясь имеющимися в библиотеке ***Boost*** структурами и алгоритмами разработать утилиту для обнаружения файлов-дубликатов.

Утилита должна иметь возможность через параметры командной строки указывать:

• директории для сканирования (может быть несколько)

• директории для исключения из сканирования (может быть несколько)

• уровень сканирования (***1*** - на все директории, ***0*** - только указанная директория без вложенных)

• минимальный размер файла, по умолчанию проверяются все файлы больше ***1 байта***.

• маски имен файлов разрешенных для сравнения (не зависят от регистра)

• размер блока, которым производится чтения файлов, в задании этот размер упоминается как ***S***

• один из имеющихся алгоритмов хэширования (***crc32***, ***md5*** - конкретные варианты определить самостоятельно), в задании эта функция упоминается как ***H***

Результатом работы утилиты должен быть список полных путей файлов с идентичным содержимым, выводимый на стандартный вывод. 

На одной строке один файл. 

Идентичные файлы должны подряд, одной группой.

Разные группы разделяются пустой строкой.

Обязательно свойство утилиты - бережное обращение с дисковым вводом выводом.

Каждый файл может быть представлен в виде списка блоков размера ***S***. 

Если размер файла не кратен, он дополняется бинарными нулями.

Файл ***world.txt*** из одной строки
***Hello, World\n***

При размере блока в 5 байт, будет представлен как

***Hello
, Wor
ld\n\0\0***

Каждый блок должен быть свернут выбранной функцией хэширования.

Возможные коллизии игнорируются. 

Из предположения, что:

***H("Hello") == A***

***H(", Wor") == B***

***H("ld\n\0\0") == C***

Наш файл ***world.txt*** может быть представлен в виде последовательности

***ABC***

Рассмотрим второй файл ***cpp.txt***

***Hello, C++\n***

Который после хэширования блоков

***H("Hello") == A***

***H(", C++") == D***

***H("\n\0\0\0\0") == E***

может быть представлен в виде последовательности ***ADE***

Порядок сравнения этих файлов должен быть максимально бережным. 

То есть обработка первого файла ***world.txt*** вообще не приводит к чтению с
диска, ведь нам еще не с чем сравнивать. 

Как только мы добираемся до файла ***cpp.txt*** только в этот момент происходит перое чтение первого блока обоих файлов. 

В данном случае блоки идентичны, и необходимо прочесть вторые блоки, которые уже различаются. 

Файлы различны, оставшиеся данные не читаются.

Файлы считаются идентичными при полном совпадении последовательности хешей блоков.

## Интерфейс

**-b**, **\--block-size**=*SIZE* : размер хэш-блока в байтах

**-e**, **\--exclude**=*DIR\...* : список директорий на исключение, путь м.б. абсолютным/относительным

**-f**, **\--hash-func**=*FUNCTION* : тип хэш-функции 

**-h**, **\--help** : список аргументов программы

**-l**, **\--level**=*FLAG* : определяет обработку поддиректорий

**-p**, **\--pattern**=*REGEX\...* : список регулярных выражений для обработки имен файлов
 
**-s**, **\--min-file**=*SIZE* : минимальный размер обрабатываемых программой файлов

## Пример

Поиск дубликатов файлов удовлетворяющих паттерну имен cmake.*\ в каталогах и подкаталогах в build и .vscode за исключением двух подкаталогов build\\.cmake и build\\_deps с использованием хэш-функции sha1:

**bayan -l 1 -e \"build\\.cmake\" \"build\\_deps" -p \"cmake.*\" -f \"sha1\" \"build\" \".vscode\"**

## Проверка
Задание считается выполнено успешно, если после просмотра кода, подключения репозитория, установки пакета и запуска бинарного файла командой (параметры из описания):

$ bayan [...]

будут обнаружены файлы-дубликаты, без ложных срабатываний и пропуска существующих дубликатов.

Количество прочитанных данных с диска минимально.
